<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>é”®ç›˜æ§åˆ¶ç‰ˆ WebAR ç²’å­åœ£è¯æ ‘ | Three.js</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <!-- ä½¿ç”¨ unpkg CDN å¼•å…¥æ‰€æœ‰ä¾èµ– -->
    <script src="https://unpkg.com/three@0.164.1/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.164.1/examples/js/controls/OrbitControls.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Microsoft YaHei', sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            cursor: none; /* éšè—é¼ æ ‡å…‰æ ‡ */
        }
        #container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        #threeCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        #debugInfo {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            z-index: 100;
            max-width: 300px;
            border: 1px solid #00ffff;
        }
        #controlPanel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 40, 60, 0.85);
            padding: 20px;
            border-radius: 15px;
            z-index: 100;
            width: 320px;
            border: 2px solid #0af;
            backdrop-filter: blur(5px);
        }
        #controlPanel h3 {
            color: #0ff;
            margin-bottom: 15px;
            text-align: center;
            border-bottom: 1px solid #0ff;
            padding-bottom: 8px;
        }
        .btn {
            display: block;
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            background: linear-gradient(45deg, #0066cc, #00aaff);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        .btn:hover {
            background: linear-gradient(45deg, #00aaff, #00ffff);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 170, 255, 0.4);
        }
        .input-group {
            margin: 15px 0;
        }
        .input-group label {
            display: block;
            margin-bottom: 5px;
            color: #a0e0ff;
        }
        .input-group input, .input-group textarea {
            width: 100%;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #00aaff;
            background: rgba(0, 20, 40, 0.8);
            color: white;
            font-size: 14px;
        }
        .input-group textarea {
            height: 80px;
            resize: vertical;
        }
        #status {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 20px;
            z-index: 100;
            border: 1px solid #ff0;
            text-align: center;
            min-width: 250px;
        }
        #blessingDisplay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3.5rem;
            font-weight: bold;
            color: #ffff00;
            text-shadow: 0 0 20px #ff0, 0 0 40px #f0f;
            z-index: 50;
            opacity: 0;
            pointer-events: none;
            text-align: center;
            white-space: nowrap;
            transition: opacity 0.5s;
        }
        #loading {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            font-size: 24px;
            color: #0ff;
            flex-direction: column;
        }
        .snowflake {
            position: absolute;
            top: -20px;
            color: white;
            font-size: 1rem;
            opacity: 0.8;
            user-select: none;
            pointer-events: none;
            z-index: 5;
        }
        #virtualHand {
            position: absolute;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0, 170, 255, 0.8), rgba(0, 100, 200, 0.3));
            border: 3px solid #0ff;
            box-shadow: 0 0 30px #0ff;
            z-index: 90;
            pointer-events: none;
            transform: translate(-50%, -50%);
            transition: transform 0.1s, width 0.3s, height 0.3s;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: white;
        }
        #keyboardHelp {
            position: absolute;
            bottom: 80px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            z-index: 100;
            max-width: 400px;
            border: 1px solid #ff9900;
        }
        .key {
            display: inline-block;
            background: #333;
            color: #ff0;
            padding: 2px 8px;
            border-radius: 4px;
            margin: 0 3px;
            font-family: monospace;
            border: 1px solid #666;
        }
        .hand-icon {
            font-size: 20px;
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div id="loading">
        <p>ğŸ® åŠ è½½é”®ç›˜æ§åˆ¶ç‰ˆç²’å­åœ£è¯æ ‘...</p>
        <p style="font-size:16px; margin-top:20px; color:#aaa;">æ— éœ€æ‘„åƒå¤´ï¼Œä½¿ç”¨é”®ç›˜æ§åˆ¶</p>
    </div>

    <div id="container">
        <!-- Three.js ç”»å¸ƒ -->
        <canvas id="threeCanvas"></canvas>
        
        <!-- è™šæ‹Ÿæ‰‹éƒ¨æŒ‡ç¤ºå™¨ -->
        <div id="virtualHand">âœ‹</div>
        
        <!-- é¡¶éƒ¨æ§åˆ¶é¢æ¿ -->
        <div id="controlPanel">
            <h3>ğŸ® é”®ç›˜æ§åˆ¶é¢æ¿</h3>
            <button class="btn" id="autoDemoBtn">ğŸ¤– è‡ªåŠ¨æ¼”ç¤ºæ¨¡å¼</button>
            <button class="btn" id="resetBtn">ğŸ„ é‡ç½®ä¸ºåœ£è¯æ ‘</button>
            
            <div class="input-group">
                <label for="photoUpload">ğŸ“· ä¸Šä¼ ç…§ç‰‡ï¼ˆé©±åŠ¨ç²’å­ï¼‰</label>
                <input type="file" id="photoUpload" accept="image/*">
                <p style="font-size:12px; color:#8af; margin-top:5px;">ç…§ç‰‡è‰²å½©å°†å½±å“ç²’å­å¤–è§‚</p>
            </div>
            
            <div class="input-group">
                <label for="promptInput">ğŸ’¬ è‡ªå®šä¹‰ç¥ç¦æç¤ºè¯</label>
                <textarea id="promptInput" placeholder="ä¾‹å¦‚ï¼šåœ£è¯å¿«ä¹ï¼Œå¹³å®‰å–œä¹ï¼">åœ£è¯å¿«ä¹ï¼Œå¹³å®‰å–œä¹ï¼</textarea>
            </div>
            
            <button class="btn" id="updatePromptBtn">âœ¨ æ›´æ–°æç¤ºè¯</button>
            
            <div class="input-group">
                <label>ğŸ¯ å½“å‰æ‰‹åŠ¿çŠ¶æ€</label>
                <div id="gestureState" style="padding:10px; background:rgba(0,50,100,0.5); border-radius:5px; margin-top:5px;">
                    ç­‰å¾…é”®ç›˜è¾“å…¥...
                </div>
            </div>
            
            <div style="margin-top: 15px; padding: 10px; background: rgba(255,100,0,0.1); border-radius: 8px; border-left: 3px solid #ff9900;">
                <p style="color:#ff9900; font-size: 12px; margin: 0;">ğŸ’¡ <strong>è™šæ‹Ÿæ‰‹æ§åˆ¶</strong></p>
                <p style="color:#ffcc00; font-size: 11px; margin-top: 5px;">ä½¿ç”¨ <span class="key">W A S D</span> æˆ– <span class="key">â†‘ â† â†“ â†’</span> ç§»åŠ¨è™šæ‹Ÿæ‰‹</p>
            </div>
        </div>
        
        <!-- è°ƒè¯•ä¿¡æ¯é¢æ¿ -->
        <div id="debugInfo">
            <h4>ğŸ”§ ç³»ç»Ÿä¿¡æ¯</h4>
            <p>ç²’å­æ•°é‡: <span id="particleCount">16,000</span></p>
            <p>ç‰©ç†æ¨¡å‹: é€Ÿåº¦ + åŠ é€Ÿåº¦</p>
            <p>æ§åˆ¶æ¨¡å¼: <span style="color:#0ff">é”®ç›˜æ§åˆ¶</span></p>
            <p>å¸§ç‡: <span id="fps">0</span> FPS</p>
            <p>è™šæ‹Ÿæ‰‹ä½ç½®: X:<span id="handX">50</span>% Y:<span id="handY">50</span>%</p>
        </div>
        
        <!-- é”®ç›˜å¸®åŠ©é¢æ¿ -->
        <div id="keyboardHelp">
            <h4 style="color:#ff9900; margin-bottom: 10px;">âŒ¨ï¸ é”®ç›˜å¿«æ·é”®</h4>
            <p><span class="hand-icon">ğŸ–ï¸</span> å¼ æ‰‹(çƒ) <span class="key">1</span></p>
            <p><span class="hand-icon">âœŒï¸</span> å‰ªåˆ€æ‰‹(æ–‡å­—) <span class="key">2</span></p>
            <p><span class="hand-icon">âœŠ</span> æ¡æ‹³(åœ†ç¯) <span class="key">3</span></p>
            <p><span class="hand-icon">â˜ï¸</span> é£ŸæŒ‡(æ˜Ÿ) <span class="key">4</span></p>
            <p><span class="hand-icon">ğŸ‘</span> ç«–æ‹‡æŒ‡(å¿ƒ) <span class="key">5</span></p>
            <p><span class="hand-icon">ğŸ’¨</span> æŒ¥æ‰‹é£æš´ <span class="key">F</span> + æ–¹å‘é”®</p>
            <p><span class="hand-icon">â•</span> æ”¾å¤§(é è¿‘) <span class="key">+</span></p>
            <p><span class="hand-icon">â–</span> ç¼©å°(è¿œç¦») <span class="key">-</span></p>
            <p><span class="hand-icon">ğŸŒ€</span> éšæœºåˆ‡æ¢ <span class="key">ç©ºæ ¼</span></p>
            <p><span class="hand-icon">â„ï¸</span> é›ªèŠ±å¼€å…³ <span class="key">S</span></p>
        </div>
        
        <!-- ç¥ç¦è¯­æ˜¾ç¤º -->
        <div id="blessingDisplay"></div>
        
        <!-- ç³»ç»ŸçŠ¶æ€æ  -->
        <div id="status">ä½¿ç”¨æ•°å­—é”® 1-5 åˆ‡æ¢ç²’å­å½¢æ€</div>
    </div>

    <!-- é›ªèŠ±å®¹å™¨ -->
    <div id="snowContainer"></div>

<script>
// ==================== å…¨å±€å˜é‡ä¸é…ç½® ====================
const CONFIG = {
    PARTICLE_COUNT: 16000,         // ç²’å­æ€»æ•°
    PARTICLE_COLOR: 0x00ffff,      // é’è‰²
    PHYSICS: {
        DAMPING: 0.95,             // é€Ÿåº¦é˜»å°¼
        ATTRACTION_FORCE: 0.02,    // å½¢æ€å¸å¼•åŠ›
        EXPLOSION_FORCE: 3.0,      // çˆ†ç‚¸è¿‡æ¸¡åŠ›
        WIND_FORCE: 0.8,           // æŒ¥æ‰‹é£åŠ› (å¢å¼º)
    },
    GESTURE: {
        OPEN_HAND: 'open',         // å¼ æ‰‹
        SCISSOR: 'scissor',        // å‰ªåˆ€æ‰‹
        FIST: 'fist',              // æ¡æ‹³
        POINT: 'point',            // é£ŸæŒ‡
        THUMB_UP: 'thumb_up',      // ç«–æ‹‡æŒ‡
    },
    KEYBOARD: {
        HAND_SPEED: 8,             // è™šæ‹Ÿæ‰‹ç§»åŠ¨é€Ÿåº¦
        MAX_HAND_SCALE: 2.0,       // æœ€å¤§æ‰‹éƒ¨ç¼©æ”¾
        MIN_HAND_SCALE: 0.5,       // æœ€å°æ‰‹éƒ¨ç¼©æ”¾
    }
};

// æ ¸å¿ƒ Three.js å˜é‡
let scene, camera, renderer, controls, particleSystem;
let particleGeometry, particleMaterial;

// ç³»ç»ŸçŠ¶æ€å˜é‡
let currentGesture = null;
let lastGestureTime = 0;
let isExploding = false;
let explosionTime = 0;
let blessingWords = ["åœ£è¯å¿«ä¹", "å¹³å®‰å–œä¹", "å¿ƒæƒ³äº‹æˆ", "å¹¸ç¦å®‰åº·", "æ–°å¹´è¿›æ­¥"];
let currentPrompt = "åœ£è¯å¿«ä¹ï¼Œå¹³å®‰å–œä¹ï¼";
let uploadedTexture = null;

// ç‰©ç†ç²’å­æ•°æ®
let particlePositions, particleVelocities, particleAccelerations;
let targetPositions = []; // ç›®æ ‡ä½ç½®ï¼ˆç”¨äºå½¢æ€å˜æ¢ï¼‰

// è™šæ‹Ÿæ‰‹çŠ¶æ€
let virtualHand = {
    x: 50,      // å±å¹•ç™¾åˆ†æ¯”ä½ç½® X (0-100)
    y: 50,      // å±å¹•ç™¾åˆ†æ¯”ä½ç½® Y (0-100)
    scale: 1.0, // æ‰‹éƒ¨ç¼©æ”¾ (æ¨¡æ‹Ÿæ·±åº¦)
    velocityX: 0,
    velocityY: 0,
    isMoving: false,
    windForce: { x: 0, y: 0 }
};

// æŒ‰é”®çŠ¶æ€è·Ÿè¸ª
let keysPressed = {};
let lastWindTime = 0;

// å¸§ç‡è®¡ç®—
let frameCount = 0, lastTime = 0, fps = 0;

// ==================== ä¸»åˆå§‹åŒ–å‡½æ•° ====================
window.onload = function() {
    console.log("å¼€å§‹åˆå§‹åŒ–é”®ç›˜æ§åˆ¶ç‰ˆç²’å­åœ£è¯æ ‘ç³»ç»Ÿ...");
    initThreeJS();
    createParticleSystem();
    initSnowflakes();
    setupEventListeners();
    initVirtualHand();
    animate();
    
    // éšè—åŠ è½½ç•Œé¢
    setTimeout(() => {
        document.getElementById('loading').style.display = 'none';
        showRandomBlessing();
    }, 1500);
    
    updateStatus("ç³»ç»Ÿå°±ç»ªï¼ä½¿ç”¨æ•°å­—é”® 1-5 åˆ‡æ¢ç²’å­å½¢æ€");
};

// ==================== Three.js åˆå§‹åŒ– ====================
function initThreeJS() {
    // åˆ›å»ºåœºæ™¯
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000011);
    scene.fog = new THREE.Fog(0x000033, 10, 50);
    
    // åˆ›å»ºç›¸æœº
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 15);
    
    // åˆ›å»ºæ¸²æŸ“å™¨
    const threeCanvas = document.getElementById('threeCanvas');
    renderer = new THREE.WebGLRenderer({ canvas: threeCanvas, alpha: true, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    
    // æ·»åŠ è½¨é“æ§åˆ¶ï¼ˆè°ƒè¯•ç”¨ï¼‰
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    
    // æ·»åŠ ç¯å¢ƒå…‰
    const ambientLight = new THREE.AmbientLight(0x222244);
    scene.add(ambientLight);
    
    // æ·»åŠ æ–¹å‘å…‰
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(10, 20, 5);
    directionalLight.castShadow = true;
    scene.add(directionalLight);
    
    // æ·»åŠ ç‚¹å…‰æºï¼ˆç²’å­é«˜å…‰ï¼‰
    const pointLight = new THREE.PointLight(0x00ffff, 2, 50);
    pointLight.position.set(0, 10, 0);
    scene.add(pointLight);
    
    // çª—å£å¤§å°è°ƒæ•´äº‹ä»¶
    window.addEventListener('resize', onWindowResize);
    
    updateStatus("Three.js åœºæ™¯åˆå§‹åŒ–å®Œæˆ");
}

// ==================== åˆ›å»ºç²’å­ç³»ç»Ÿ ====================
function createParticleSystem() {
    // åˆ›å»ºç²’å­å‡ ä½•ä½“
    particleGeometry = new THREE.BufferGeometry();
    
    // åˆå§‹åŒ–ç²’å­ä½ç½®ã€é€Ÿåº¦ã€åŠ é€Ÿåº¦æ•°ç»„
    const positions = new Float32Array(CONFIG.PARTICLE_COUNT * 3);
    const colors = new Float32Array(CONFIG.PARTICLE_COUNT * 3);
    particleVelocities = new Array(CONFIG.PARTICLE_COUNT);
    particleAccelerations = new Array(CONFIG.PARTICLE_COUNT);
    targetPositions = new Array(CONFIG.PARTICLE_COUNT);
    
    // åœ£è¯æ ‘å½¢çŠ¶çš„ç›®æ ‡ä½ç½®ï¼ˆåœ†é”¥å½¢ï¼‰
    for (let i = 0; i < CONFIG.PARTICLE_COUNT; i++) {
        const i3 = i * 3;
        
        // åœ¨åœ†é”¥èŒƒå›´å†…éšæœºç”Ÿæˆä½ç½®
        const height = Math.random(); // 0åˆ°1çš„é«˜åº¦
        const angle = Math.random() * Math.PI * 2;
        const radius = (1 - height) * 5; // è¶Šå¾€ä¸ŠåŠå¾„è¶Šå°
        
        // ç›®æ ‡ä½ç½®ï¼šåœ£è¯æ ‘å½¢çŠ¶
        const x = Math.cos(angle) * radius * (Math.random() * 0.3 + 0.7);
        const y = height * 10 - 2; // æ€»é«˜10ä¸ªå•ä½ï¼Œåº•éƒ¨åœ¨y=-2
        const z = Math.sin(angle) * radius * (Math.random() * 0.3 + 0.7);
        
        targetPositions[i] = new THREE.Vector3(x, y, z);
        
        // åˆå§‹ä½ç½®ï¼šéšæœºåˆ†æ•£åœ¨ç©ºé—´
        positions[i3] = (Math.random() - 0.5) * 20;
        positions[i3 + 1] = (Math.random() - 0.5) * 20;
        positions[i3 + 2] = (Math.random() - 0.5) * 20;
        
        // é’è‰²ç³»é¢œè‰²
        colors[i3] = 0.0;      // R
        colors[i3 + 1] = 1.0;  // G
        colors[i3 + 2] = 1.0;  // B
        
        // åˆå§‹åŒ–é€Ÿåº¦å’ŒåŠ é€Ÿåº¦
        particleVelocities[i] = new THREE.Vector3(0, 0, 0);
        particleAccelerations[i] = new THREE.Vector3(0, 0, 0);
    }
    
    particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    
    // åˆ›å»ºç²’å­æè´¨
    particleMaterial = new THREE.PointsMaterial({
        size: 0.08,
        vertexColors: true,
        transparent: true,
        opacity: 0.9,
        blending: THREE.AdditiveBlending,
        sizeAttenuation: true
    });
    
    // åˆ›å»ºç²’å­ç³»ç»Ÿ
    particleSystem = new THREE.Points(particleGeometry, particleMaterial);
    scene.add(particleSystem);
    
    // é¢„å®šä¹‰å…¶ä»–å½¢æ€çš„ç›®æ ‡ä½ç½®
    defineParticleShapes();
    
    updateStatus(`å·²åˆ›å»º ${CONFIG.PARTICLE_COUNT.toLocaleString()} ä¸ªæµä½“ç²’å­`);
}

// ==================== å®šä¹‰ç²’å­å½¢æ€ ====================
function defineParticleShapes() {
    // å½¢æ€1ï¼šçƒä½“ï¼ˆå¼ æ‰‹ï¼‰
    particleTargets = particleTargets || {};
    particleTargets.sphere = [];
    for (let i = 0; i < CONFIG.PARTICLE_COUNT; i++) {
        const phi = Math.acos(2 * Math.random() - 1);
        const theta = Math.random() * Math.PI * 2;
        const radius = 4;
        
        const x = radius * Math.sin(phi) * Math.cos(theta);
        const y = radius * Math.sin(phi) * Math.sin(theta);
        const z = radius * Math.cos(phi);
        
        particleTargets.sphere[i] = new THREE.Vector3(x, y, z);
    }
    
    // å½¢æ€2ï¼šæ–‡å­—ï¼ˆå‰ªåˆ€æ‰‹ï¼‰- "æˆ‘æ˜¯ Mok"
    particleTargets.text = [];
    // åˆ›å»ºæ–‡å­—å½¢çŠ¶çš„ç²’å­åˆ†å¸ƒ
    for (let i = 0; i < CONFIG.PARTICLE_COUNT; i++) {
        // åˆ›å»ºç®€å•çš„æ–‡å­—å½¢çŠ¶
        let x = 0, y = 0, z = 0;
        
        // æ ¹æ®ä½ç½®åˆ›å»º"MOK"å­—æ ·ï¼ˆç®€åŒ–ç‰ˆï¼‰
        const charWidth = 12;
        const charHeight = 8;
        const charSpacing = 3;
        
        // å°†ç²’å­åˆ†é…åˆ°ä¸‰ä¸ªå­—æ¯
        const letterIndex = Math.floor(i / (CONFIG.PARTICLE_COUNT / 3));
        const particleInLetter = i % (CONFIG.PARTICLE_COUNT / 3);
        
        // ä¸ºæ¯ä¸ªå­—æ¯åˆ›å»ºä¸åŒçš„å½¢çŠ¶
        if (letterIndex === 0) { // M
            x = (Math.random() - 0.5) * charWidth - (charWidth + charSpacing);
            y = (Math.random() - 0.5) * charHeight;
            // Mçš„å½¢çŠ¶ï¼šä¸¤ç«–åŠ ä¸¤ä¸ªæ–œçº¿
            const inM = (Math.abs(x) < 1.5 && y > -2 && y < 2) || 
                       (Math.abs(x + 3) < 1 && y > -2 && y < 2) || 
                       (Math.abs(x - 3) < 1 && y > -2 && y < 2) ||
                       (Math.abs(x) < 4 && Math.abs(y - x/2) < 0.5 && x > -3 && x < 0) ||
                       (Math.abs(x) < 4 && Math.abs(y + x/2) < 0.5 && x > 0 && x < 3);
            
            if (!inM && Math.random() > 0.3) {
                // ä¸åœ¨å­—æ¯å†…çš„ç²’å­åˆ†æ•£
                x = (Math.random() - 0.5) * 20;
                y = (Math.random() - 0.5) * 20;
                z = (Math.random() - 0.5) * 10;
            }
        } else if (letterIndex === 1) { // O
            x = (Math.random() - 0.5) * charWidth;
            y = (Math.random() - 0.5) * charHeight;
            // Oçš„å½¢çŠ¶ï¼šåœ†ç¯
            const dist = Math.sqrt(x*x + y*y);
            const inO = dist > 2 && dist < 4;
            
            if (!inO && Math.random() > 0.3) {
                x = (Math.random() - 0.5) * 20;
                y = (Math.random() - 0.5) * 20;
                z = (Math.random() - 0.5) * 10;
            }
        } else { // K
            x = (Math.random() - 0.5) * charWidth + (charWidth + charSpacing);
            y = (Math.random() - 0.5) * charHeight;
            // Kçš„å½¢çŠ¶ï¼šä¸€ç«–åŠ ä¸¤ä¸ªæ–œçº¿
            const inK = (Math.abs(x) < 1 && y > -3 && y < 3) || 
                       (Math.abs(y - x) < 1 && x > 0 && x < 4 && y > -2 && y < 4) ||
                       (Math.abs(y + x) < 1 && x > 0 && x < 4 && y > -4 && y < 2);
            
            if (!inK && Math.random() > 0.3) {
                x = (Math.random() - 0.5) * 20;
                y = (Math.random() - 0.5) * 20;
                z = (Math.random() - 0.5) * 10;
            }
        }
        
        particleTargets.text[i] = new THREE.Vector3(x * 0.5, y * 0.5, z);
    }
    
    // å½¢æ€3ï¼šåœ†ç¯ï¼ˆæ¡æ‹³ï¼‰
    particleTargets.ring = [];
    for (let i = 0; i < CONFIG.PARTICLE_COUNT; i++) {
        const angle = Math.random() * Math.PI * 2;
        const radius = 5;
        const width = 0.5;
        
        const x = Math.cos(angle) * (radius + (Math.random() - 0.5) * width);
        const y = (Math.random() - 0.5) * 0.5;
        const z = Math.sin(angle) * (radius + (Math.random() - 0.5) * width);
        
        particleTargets.ring[i] = new THREE.Vector3(x, y, z);
    }
    
    // å½¢æ€4ï¼šæ˜Ÿæ˜Ÿï¼ˆé£ŸæŒ‡ï¼‰
    particleTargets.star = [];
    for (let i = 0; i < CONFIG.PARTICLE_COUNT; i++) {
        // ç”Ÿæˆäº”è§’æ˜Ÿå½¢çŠ¶çš„ç²’å­åˆ†å¸ƒ
        const points = 5;
        const pointIndex = Math.floor(Math.random() * points);
        const angle = pointIndex * (Math.PI * 2 / points);
        
        // äº”è§’æ˜Ÿå†…å¤–ç‚¹
        const isOuter = Math.random() > 0.5;
        const radius = isOuter ? 4 : 2;
        
        const x = Math.cos(angle) * radius;
        const y = Math.sin(angle) * radius;
        const z = (Math.random() - 0.5) * 1;
        
        particleTargets.star[i] = new THREE.Vector3(x, y, z);
    }
    
    // å½¢æ€5ï¼šçˆ±å¿ƒï¼ˆç«–å¤§æ‹‡æŒ‡ï¼‰
    particleTargets.heart = [];
    for (let i = 0; i < CONFIG.PARTICLE_COUNT; i++) {
        // å¿ƒå½¢å‚æ•°æ–¹ç¨‹ (ç®€åŒ–ç‰ˆ)
        const t = Math.random() * Math.PI * 2;
        const scale = 3;
        
        const x = scale * 16 * Math.pow(Math.sin(t), 3);
        const y = scale * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
        const z = (Math.random() - 0.5) * 2;
        
        particleTargets.heart[i] = new THREE.Vector3(x * 0.015, -y * 0.015 + 1.5, z);
    }
}

// ==================== åˆ‡æ¢ç²’å­å½¢æ€ ====================
function switchParticleShape(gesture) {
    const shapeMap = {
        'open': 'sphere',
        'scissor': 'text',
        'fist': 'ring',
        'point': 'star',
        'thumb_up': 'heart'
    };
    
    const targetShape = shapeMap[gesture];
    if (!targetShape || !particleTargets[targetShape]) {
        console.warn(`æœªçŸ¥çš„ç²’å­å½¢æ€: ${gesture}`);
        return;
    }
    
    // æ›´æ–°ç›®æ ‡ä½ç½®
    for (let i = 0; i < CONFIG.PARTICLE_COUNT; i++) {
        if (particleTargets[targetShape][i]) {
            targetPositions[i].copy(particleTargets[targetShape][i]);
        }
    }
    
    // æ›´æ–°UIæ˜¾ç¤º
    const gestureNames = {
        'open': 'ğŸ–ï¸ å¼ æ‰‹ - çƒä½“å½¢æ€',
        'scissor': 'âœŒï¸ å‰ªåˆ€æ‰‹ - æ–‡å­—å½¢æ€"æˆ‘æ˜¯Mok"',
        'fist': 'âœŠ æ¡æ‹³ - åœ†ç¯å½¢æ€',
        'point': 'â˜ï¸ é£ŸæŒ‡ - æ˜Ÿæ˜Ÿå½¢æ€',
        'thumb_up': 'ğŸ‘ ç«–æ‹‡æŒ‡ - çˆ±å¿ƒå½¢æ€'
    };
    
    document.getElementById('gestureState').innerHTML = 
        gestureNames[gesture] || 'æœªçŸ¥æ‰‹åŠ¿';
    
    updateStatus(`åˆ‡æ¢åˆ°: ${gestureNames[gesture]}`);
}

// ==================== æ‰‹åŠ¿å˜åŒ–å¤„ç† ====================
function onGestureChanged(newGesture) {
    // é˜²æ­¢è¿‡å¿«åˆ‡æ¢
    const now = Date.now();
    if (now - lastGestureTime < 500) return;
    
    lastGestureTime = now;
    currentGesture = newGesture;
    
    // è§¦å‘çˆ†ç‚¸è¿‡æ¸¡ç‰¹æ•ˆ
    triggerExplosion();
    
    // åˆ‡æ¢ç²’å­å½¢æ€
    setTimeout(() => {
        switchParticleShape(newGesture);
    }, 300);
    
    // éšæœºæ˜¾ç¤ºç¥ç¦è¯­
    showRandomBlessing();
}

// ==================== çˆ†ç‚¸è¿‡æ¸¡ç‰¹æ•ˆ ====================
function triggerExplosion() {
    isExploding = true;
    explosionTime = 0;
    
    // ä¸ºæ‰€æœ‰ç²’å­æ–½åŠ éšæœºçˆ†ç‚¸åŠ›
    for (let i = 0; i < CONFIG.PARTICLE_COUNT; i++) {
        const explosionForce = new THREE.Vector3(
            (Math.random() - 0.5) * CONFIG.PHYSICS.EXPLOSION_FORCE,
            (Math.random() - 0.5) * CONFIG.PHYSICS.EXPLOSION_FORCE,
            (Math.random() - 0.5) * CONFIG.PHYSICS.EXPLOSION_FORCE
        );
        
        particleVelocities[i].add(explosionForce);
    }
    
    // æ’­æ”¾çˆ†ç‚¸éŸ³æ•ˆï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
    playExplosionSound();
}

// ==================== æ’­æ”¾çˆ†ç‚¸éŸ³æ•ˆ ====================
function playExplosionSound() {
    // åˆ›å»ºç®€å•çš„çˆ†ç ´éŸ³æ•ˆ
    try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.5);
        
        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
        
        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.5);
    } catch (e) {
        console.log("æ— æ³•æ’­æ”¾éŸ³é¢‘:", e);
    }
}

// ==================== æŒ¥æ‰‹é£æš´ ====================
function applyWindForce(windX, windY, strength = 1.0) {
    const windForce = new THREE.Vector3(
        windX * CONFIG.PHYSICS.WIND_FORCE * strength,
        windY * CONFIG.PHYSICS.WIND_FORCE * strength,
        0
    );
    
    // ä¸ºç²’å­æ–½åŠ é£åŠ›
    for (let i = 0; i < CONFIG.PARTICLE_COUNT; i++) {
        particleAccelerations[i].add(windForce.clone().multiplyScalar(Math.random() * 0.5 + 0.5));
    }
    
    // æ˜¾ç¤ºé£æš´æ•ˆæœ
    if (strength > 1.5) {
        updateStatus(`ğŸ’¨ æŒ¥æ‰‹é£æš´ï¼å¼ºåº¦: ${strength.toFixed(1)}`);
    }
}

// ==================== åˆå§‹åŒ–è™šæ‹Ÿæ‰‹ ====================
function initVirtualHand() {
    const handEl = document.getElementById('virtualHand');
    
    // æ›´æ–°è™šæ‹Ÿæ‰‹ä½ç½®
    function updateHandPosition() {
        handEl.style.left = virtualHand.x + '%';
        handEl.style.top = virtualHand.y + '%';
        
        // æ ¹æ®ç¼©æ”¾è°ƒæ•´å¤§å°
        const size = 80 + virtualHand.scale * 40;
        handEl.style.width = size + 'px';
        handEl.style.height = size + 'px';
        
        // æ›´æ–°æ‰‹éƒ¨å›¾æ ‡
        const icons = {
            'open': 'ğŸ–ï¸',
            'scissor': 'âœŒï¸',
            'fist': 'âœŠ',
            'point': 'â˜ï¸',
            'thumb_up': 'ğŸ‘'
        };
        
        handEl.textContent = icons[currentGesture] || 'âœ‹';
        
        // æ›´æ–°è°ƒè¯•ä¿¡æ¯
        document.getElementById('handX').textContent = Math.round(virtualHand.x);
        document.getElementById('handY').textContent = Math.round(virtualHand.y);
        
        // æ ¹æ®æ‰‹éƒ¨ç¼©æ”¾è°ƒæ•´ç²’å­ç³»ç»Ÿï¼ˆæ·±åº¦æ¨æ‹‰ï¼‰
        const targetScale = 0.5 + (virtualHand.scale - 0.5) * 2;
        particleSystem.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1);
    }
    
    // åˆå§‹ä½ç½®
    updateHandPosition();
    
    // åŠ¨ç”»å¾ªç¯ä¸­æ›´æ–°
    setInterval(updateHandPosition, 16);
}

// ==================== ç‰©ç†æ¨¡æ‹Ÿæ›´æ–° ====================
function updatePhysics() {
    const positions = particleGeometry.attributes.position.array;
    
    // å¤„ç†è™šæ‹Ÿæ‰‹ç§»åŠ¨
    if (virtualHand.isMoving) {
        virtualHand.x += virtualHand.velocityX;
        virtualHand.y += virtualHand.velocityY;
        
        // é™åˆ¶åœ¨å±å¹•èŒƒå›´å†…
        virtualHand.x = Math.max(5, Math.min(95, virtualHand.x));
        virtualHand.y = Math.max(5, Math.min(95, virtualHand.y));
        
        // å¦‚æœæ­£åœ¨ç§»åŠ¨ä¸”æœ‰é£åŠ›ï¼Œåº”ç”¨é£åŠ›
        if (virtualHand.windForce.x !== 0 || virtualHand.windForce.y !== 0) {
            applyWindForce(virtualHand.windForce.x, virtualHand.windForce.y, 
                          Math.sqrt(virtualHand.velocityX*virtualHand.velocityX + 
                                   virtualHand.velocityY*virtualHand.velocityY) / 5);
        }
    }
    
    for (let i = 0; i < CONFIG.PARTICLE_COUNT; i++) {
        const i3 = i * 3;
        
        // è·å–å½“å‰ç²’å­ä½ç½®
        const currentPos = new THREE.Vector3(
            positions[i3],
            positions[i3 + 1],
            positions[i3 + 2]
        );
        
        // è·å–ç›®æ ‡ä½ç½®
        const targetPos = targetPositions[i];
        
        // è®¡ç®—å¸å¼•åŠ›ï¼ˆæŒ‡å‘ç›®æ ‡ä½ç½®ï¼‰
        const attraction = new THREE.Vector3()
            .subVectors(targetPos, currentPos)
            .multiplyScalar(CONFIG.PHYSICS.ATTRACTION_FORCE);
        
        // æ›´æ–°åŠ é€Ÿåº¦
        particleAccelerations[i].add(attraction);
        
        // åº”ç”¨çˆ†ç‚¸æ•ˆæœï¼ˆå¦‚æœæœ‰ï¼‰
        if (isExploding) {
            explosionTime += 0.016;
            if (explosionTime > 1.0) {
                isExploding = false;
            }
        }
        
        // æ›´æ–°é€Ÿåº¦ï¼šv = v + a * dt
        particleVelocities[i].add(particleAccelerations[i]);
        
        // åº”ç”¨é˜»å°¼
        particleVelocities[i].multiplyScalar(CONFIG.PHYSICS.DAMPING);
        
        // æ›´æ–°ä½ç½®ï¼šp = p + v * dt
        positions[i3] += particleVelocities[i].x;
        positions[i3 + 1] += particleVelocities[i].y;
        positions[i3 + 2] += particleVelocities[i].z;
        
        // é‡ç½®åŠ é€Ÿåº¦
        particleAccelerations[i].set(0, 0, 0);
    }
    
    particleGeometry.attributes.position.needsUpdate = true;
}

// ==================== é›ªèŠ±æ•ˆæœ ====================
function initSnowflakes() {
    const container = document.getElementById('snowContainer');
    
    // å®šä¹‰é›ªèŠ±ç±»å‹
    const snowTypes = ['â„', 'â…', 'â†', 'â€¢', 'âœ¦', 'ï¼Š', 'âœ§'];
    
    function createSnowflake() {
        const snowflake = document.createElement('div');
        snowflake.className = 'snowflake';
        snowflake.innerHTML = snowTypes[Math.floor(Math.random() * snowTypes.length)];
        
        // éšæœºä½ç½®
        snowflake.style.left = Math.random() * 100 + 'vw';
        
        // éšæœºå¤§å°
        const size = Math.random() * 20 + 10;
        snowflake.style.fontSize = size + 'px';
        
        // éšæœºé€æ˜åº¦
        snowflake.style.opacity = Math.random() * 0.5 + 0.3;
        
        // éšæœºåŠ¨ç”»æ—¶é•¿
        const duration = Math.random() * 10 + 5;
        snowflake.style.animation = `fall ${duration}s linear infinite`;
        
        // éšæœºé£˜åŠ¨
        const sway = Math.random() * 100 - 50;
        snowflake.style.setProperty('--sway', sway + 'px');
        
        container.appendChild(snowflake);
        
        // é›ªèŠ±è½åœ°åç§»é™¤
        setTimeout(() => {
            if (snowflake.parentNode) {
                snowflake.remove();
            }
        }, duration * 1000);
    }
    
    // åˆ›å»ºåˆå§‹é›ªèŠ±
    for (let i = 0; i < 80; i++) {
        setTimeout(createSnowflake, Math.random() * 2000);
    }
    
    // æŒç»­ç”Ÿæˆé›ªèŠ±
    setInterval(createSnowflake, 300);
}

// ==================== ç¥ç¦è¯­æ˜¾ç¤º ====================
function showRandomBlessing() {
    const blessingDisplay = document.getElementById('blessingDisplay');
    
    // éšæœºé€‰æ‹©ç¥ç¦è¯­
    const randomIndex = Math.floor(Math.random() * blessingWords.length);
    const blessing = blessingWords[randomIndex];
    
    // æ›´æ–°æ˜¾ç¤º
    blessingDisplay.textContent = blessing;
    blessingDisplay.style.opacity = 1;
    
    // æ·»åŠ éšæœºé¢œè‰²å’ŒåŠ¨ç”»
    const colors = ['#ff0000', '#00ff00', '#ffff00', '#00ffff', '#ff00ff', '#ffa500'];
    const randomColor = colors[Math.floor(Math.random() * colors.length)];
    blessingDisplay.style.color = randomColor;
    blessingDisplay.style.textShadow = `0 0 20px ${randomColor}, 0 0 40px ${randomColor}`;
    
    // 3ç§’åæ·¡å‡º
    setTimeout(() => {
        blessingDisplay.style.opacity = 0;
    }, 3000);
}

// ==================== æ›´æ–°æç¤ºè¯ ====================
function updatePrompt() {
    const promptInput = document.getElementById('promptInput');
    currentPrompt = promptInput.value.trim() || "åœ£è¯å¿«ä¹ï¼Œå¹³å®‰å–œä¹ï¼";
    
    // å°†æç¤ºè¯æ‹†åˆ†ä¸ºå•è¯ï¼Œæ·»åŠ åˆ°ç¥ç¦è¯­åº“
    const words = currentPrompt.split(/[ï¼Œ,ã€‚.!ï¼\s]+/).filter(w => w.length > 0);
    if (words.length > 0) {
        blessingWords = [...words, ...["å¿ƒæƒ³äº‹æˆ", "å¹¸ç¦å®‰åº·", "æ–°å¹´è¿›æ­¥"]];
    }
    
    updateStatus(`æç¤ºè¯å·²æ›´æ–°: ${currentPrompt}`);
    showRandomBlessing();
}

// ==================== å¤„ç†ç…§ç‰‡ä¸Šä¼  ====================
function handlePhotoUpload(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = function(e) {
        const image = new Image();
        image.onload = function() {
            // åˆ›å»ºçº¹ç†
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 256;
            ctx.drawImage(image, 0, 0, 256, 256);
            
            // æ›´æ–°ç²’å­é¢œè‰²åŸºäºå›¾åƒ
            updateParticleColorsFromImage(canvas);
            
            updateStatus(`ç…§ç‰‡å·²åŠ è½½: ${file.name}`);
        };
        image.src = e.target.result;
    };
    reader.readAsDataURL(file);
}

// ==================== ä»å›¾åƒæ›´æ–°ç²’å­é¢œè‰² ====================
function updateParticleColorsFromImage(canvas) {
    const ctx = canvas.getContext('2d');
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    
    const colors = particleGeometry.attributes.color.array;
    
    for (let i = 0; i < CONFIG.PARTICLE_COUNT; i++) {
        const i3 = i * 3;
        
        // éšæœºä»å›¾åƒä¸­é‡‡æ ·é¢œè‰²
        const pixelIndex = Math.floor(Math.random() * (data.length / 4)) * 4;
        
        colors[i3] = data[pixelIndex] / 255;     // R
        colors[i3 + 1] = data[pixelIndex + 1] / 255; // G
        colors[i3 + 2] = data[pixelIndex + 2] / 255; // B
    }
    
    particleGeometry.attributes.color.needsUpdate = true;
}

// ==================== é‡ç½®ä¸ºåœ£è¯æ ‘ ====================
function resetToChristmasTree() {
    // å°†ç›®æ ‡ä½ç½®é‡ç½®ä¸ºåœ£è¯æ ‘å½¢çŠ¶
    for (let i = 0; i < CONFIG.PARTICLE_COUNT; i++) {
        // é‡æ–°è®¡ç®—åœ£è¯æ ‘ä½ç½®
        const height = Math.random();
        const angle = Math.random() * Math.PI * 2;
        const radius = (1 - height) * 5;
        
        const x = Math.cos(angle) * radius * (Math.random() * 0.3 + 0.7);
        const y = height * 10 - 2;
        const z = Math.sin(angle) * radius * (Math.random() * 0.3 + 0.7);
        
        targetPositions[i].set(x, y, z);
    }
    
    // è§¦å‘æ¸©å’Œçš„çˆ†ç‚¸æ•ˆæœ
    triggerExplosion();
    
    updateStatus("ç²’å­å·²é‡ç½®ä¸ºåœ£è¯æ ‘å½¢æ€");
}

// ==================== è‡ªåŠ¨æ¼”ç¤ºæ¨¡å¼ ====================
function startAutoDemo() {
    let demoStep = 0;
    const demoSteps = [
        { gesture: 'open', duration: 3000 },
        { gesture: 'scissor', duration: 3000 },
        { gesture: 'fist', duration: 3000 },
        { gesture: 'point', duration: 3000 },
        { gesture: 'thumb_up', duration: 3000 },
    ];
    
    function nextStep() {
        if (demoStep >= demoSteps.length) {
            demoStep = 0; // å¾ªç¯
        }
        
        const step = demoSteps[demoStep];
        onGestureChanged(step.gesture);
        
        // éšæœºç§»åŠ¨è™šæ‹Ÿæ‰‹
        virtualHand.velocityX = (Math.random() - 0.5) * 4;
        virtualHand.velocityY = (Math.random() - 0.5) * 4;
        virtualHand.isMoving = true;
        
        // æ¨¡æ‹ŸæŒ¥æ‰‹é£æš´
        if (Math.random() > 0.7) {
            setTimeout(() => {
                applyWindForce(
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10,
                    2.0
                );
            }, 1000);
        }
        
        demoStep++;
        
        // ä¸‹ä¸€æ­¥
        setTimeout(() => {
            virtualHand.isMoving = false;
            virtualHand.velocityX = 0;
            virtualHand.velocityY = 0;
            setTimeout(nextStep, 500);
        }, step.duration);
    }
    
    nextStep();
    updateStatus("ğŸ¤– è‡ªåŠ¨æ¼”ç¤ºæ¨¡å¼å·²å¯åŠ¨");
}

// ==================== é”®ç›˜æ§åˆ¶é€»è¾‘ ====================
function setupKeyboardControls() {
    // é”®ç›˜æŒ‰ä¸‹äº‹ä»¶
    document.addEventListener('keydown', function(e) {
        keysPressed[e.key.toLowerCase()] = true;
        
        // é˜²æ­¢é»˜è®¤è¡Œä¸º
        if (['1','2','3','4','5',' ','f','s','+','-'].includes(e.key.toLowerCase())) {
            e.preventDefault();
        }
        
        // æ•°å­—é”® 1-5: åˆ‡æ¢æ‰‹åŠ¿
        if (e.key === '1') onGestureChanged('open');
        if (e.key === '2') onGestureChanged('scissor');
        if (e.key === '3') onGestureChanged('fist');
        if (e.key === '4') onGestureChanged('point');
        if (e.key === '5') onGestureChanged('thumb_up');
        
        // ç©ºæ ¼é”®: éšæœºåˆ‡æ¢æ‰‹åŠ¿
        if (e.key === ' ') {
            const gestures = ['open', 'scissor', 'fist', 'point', 'thumb_up'];
            const randomGesture = gestures[Math.floor(Math.random() * gestures.length)];
            onGestureChanged(randomGesture);
        }
        
        // Fé”®: å¼€å§‹æŒ¥æ‰‹é£æš´
        if (e.key.toLowerCase() === 'f') {
            virtualHand.windForce.x = virtualHand.velocityX * 3;
            virtualHand.windForce.y = virtualHand.velocityY * 3;
        }
        
        // Sé”®: åˆ‡æ¢é›ªèŠ±æ•ˆæœ
        if (e.key.toLowerCase() === 's') {
            const snowflakes = document.querySelectorAll('.snowflake');
            const isPaused = snowflakes[0]?.style.animationPlayState === 'paused';
            snowflakes.forEach(snow => {
                snow.style.animationPlayState = isPaused ? 'running' : 'paused';
            });
            updateStatus(isPaused ? "â„ï¸ é›ªèŠ±æ•ˆæœå·²æ¢å¤" : "â„ï¸ é›ªèŠ±æ•ˆæœå·²æš‚åœ");
        }
        
        // +é”®: æ”¾å¤§è™šæ‹Ÿæ‰‹ï¼ˆæ¨¡æ‹Ÿé è¿‘ï¼‰
        if (e.key === '+' || e.key === '=') {
            virtualHand.scale = Math.min(CONFIG.KEYBOARD.MAX_HAND_SCALE, virtualHand.scale + 0.1);
            updateStatus(`â• æ‰‹éƒ¨æ”¾å¤§: ${virtualHand.scale.toFixed(1)}x`);
        }
        
        // -é”®: ç¼©å°è™šæ‹Ÿæ‰‹ï¼ˆæ¨¡æ‹Ÿè¿œç¦»ï¼‰
        if (e.key === '-' || e.key === '_') {
            virtualHand.scale = Math.max(CONFIG.KEYBOARD.MIN_HAND_SCALE, virtualHand.scale - 0.1);
            updateStatus(`â– æ‰‹éƒ¨ç¼©å°: ${virtualHand.scale.toFixed(1)}x`);
        }
        
        // æ–¹å‘é”®/WASD: ç§»åŠ¨è™šæ‹Ÿæ‰‹
        handleHandMovement();
    });
    
    // é”®ç›˜é‡Šæ”¾äº‹ä»¶
    document.addEventListener('keyup', function(e) {
        keysPressed[e.key.toLowerCase()] = false;
        
        // Fé”®é‡Šæ”¾: åœæ­¢æŒ¥æ‰‹é£æš´
        if (e.key.toLowerCase() === 'f') {
            virtualHand.windForce.x = 0;
            virtualHand.windForce.y = 0;
        }
        
        // åœæ­¢ç§»åŠ¨
        if (['w','a','s','d','arrowup','arrowleft','arrowdown','arrowright'].includes(e.key.toLowerCase())) {
            virtualHand.isMoving = false;
            virtualHand.velocityX = 0;
            virtualHand.velocityY = 0;
        }
    });
    
    // é¼ æ ‡ç‚¹å‡»æ˜¾ç¤ºç¥ç¦
    document.addEventListener('click', function(e) {
        if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA' && e.target.tagName !== 'BUTTON') {
            showRandomBlessing();
        }
    });
}

// ==================== å¤„ç†è™šæ‹Ÿæ‰‹ç§»åŠ¨ ====================
function handleHandMovement() {
    // é‡ç½®é€Ÿåº¦
    virtualHand.velocityX = 0;
    virtualHand.velocityY = 0;
    
    // WASD æ§åˆ¶
    if (keysPressed['w'] || keysPressed['arrowup']) {
        virtualHand.velocityY = -CONFIG.KEYBOARD.HAND_SPEED;
        virtualHand.isMoving = true;
    }
    if (keysPressed['s'] || keysPressed['arrowdown']) {
        virtualHand.velocityY = CONFIG.KEYBOARD.HAND_SPEED;
        virtualHand.isMoving = true;
    }
    if (keysPressed['a'] || keysPressed['arrowleft']) {
        virtualHand.velocityX = -CONFIG.KEYBOARD.HAND_SPEED;
        virtualHand.isMoving = true;
    }
    if (keysPressed['d'] || keysPressed['arrowright']) {
        virtualHand.velocityX = CONFIG.KEYBOARD.HAND_SPEED;
        virtualHand.isMoving = true;
    }
    
    // å¦‚æœåŒæ—¶æŒ‰ä¸‹äº†Fé”®ï¼Œå¢åŠ é£åŠ›
    if (keysPressed['f'] && virtualHand.isMoving) {
        virtualHand.windForce.x = virtualHand.velocityX * 3;
        virtualHand.windForce.y = virtualHand.velocityY * 3;
        
        // æ¯200msåº”ç”¨ä¸€æ¬¡é£åŠ›
        const now = Date.now();
        if (now - lastWindTime > 200) {
            applyWindForce(virtualHand.windForce.x, virtualHand.windForce.y, 1.5);
            lastWindTime = now;
        }
    }
}

// ==================== äº‹ä»¶ç›‘å¬å™¨è®¾ç½® ====================
function setupEventListeners() {
    // è‡ªåŠ¨æ¼”ç¤ºæŒ‰é’®
    document.getElementById('autoDemoBtn').addEventListener('click', startAutoDemo);
    
    // é‡ç½®æŒ‰é’®
    document.getElementById('resetBtn').addEventListener('click', resetToChristmasTree);
    
    // ç…§ç‰‡ä¸Šä¼ 
    document.getElementById('photoUpload').addEventListener('change', handlePhotoUpload);
    
    // æ›´æ–°æç¤ºè¯
    document.getElementById('updatePromptBtn').addEventListener('click', updatePrompt);
    
    // è®¾ç½®é”®ç›˜æ§åˆ¶
    setupKeyboardControls();
}

// ==================== å¸§ç‡è®¡ç®— ====================
function updateFPS() {
    frameCount++;
    const now = performance.now();
    
    if (now >= lastTime + 1000) {
        fps = Math.round((frameCount * 1000) / (now - lastTime));
        document.getElementById('fps').textContent = fps;
        frameCount = 0;
        lastTime = now;
    }
}

// ==================== çŠ¶æ€æ›´æ–° ====================
function updateStatus(message) {
    const statusEl = document.getElementById('status');
    statusEl.textContent = `ğŸ“¡ ${message}`;
    console.log(`[ç³»ç»ŸçŠ¶æ€] ${message}`);
}

// ==================== çª—å£å¤§å°è°ƒæ•´ ====================
function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

// ==================== åŠ¨ç”»å¾ªç¯ ====================
function animate() {
    requestAnimationFrame(animate);
    
    // æ›´æ–°ç‰©ç†
    updatePhysics();
    
    // æ›´æ–°å¸§ç‡
    updateFPS();
    
    // æ›´æ–°æ§åˆ¶
    controls.update();
    
    // æ¸²æŸ“åœºæ™¯
    renderer.render(scene, camera);
}

// ==================== åˆå§‹åŒ–å®Œæˆ ====================
updateStatus("ğŸ® é”®ç›˜æ§åˆ¶ç‰ˆç²’å­åœ£è¯æ ‘ç³»ç»Ÿå°±ç»ªï¼");
console.log("ğŸ„ é”®ç›˜æ§åˆ¶ç‰ˆç²’å­åœ£è¯æ ‘ç³»ç»Ÿå‡†å¤‡å°±ç»ªï¼");
</script>
</body>
</html>
